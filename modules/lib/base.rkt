#lang racket/base
(require (for-syntax racket/base
                     syntax/parse
                     unstable/syntax)
         racket/contract/base
         racket/match
         racket/list)

;; Everything exciting happens in this module. Unfortunately, it is
;; not written in the order it should be read. I'll annotate with a
;; letter where you should start. So find (A).

;; (C) The various parameters just provide a quick way to cons things
;; on to a list. Goto (D)
(define-syntax-rule (define-cons-param current-types cons-type!)
  (begin
    (define current-types
      (make-parameter #f))
    (define (cons-type! n)
      (define ts-b (current-types))
      (set-box! ts-b (cons n (unbox ts-b))))))

(define-cons-param current-types cons-type!)
(define-cons-param current-types-requires cons-types-requires!)
(define-cons-param current-exports cons-export!)
(define-cons-param current-exports-requires cons-exports-requires!)

;; (B) The submodules that record the various lists have this funny
;; set up: They all define the box, then set a parameter to it. Why do
;; we need the parameter? Because the name 'types' has the lexical
;; context of the macro that produced it, meaning other macros can't
;; access it. So, the parameter has the lexical context of "base.rkt"
;; and it is an indirection point for all the submodules.
;;
;; Goto (C)
(define-syntax-rule (define-cons-param-submod current-types types)
  (module+ types
    (define types (box null))
    (provide types)
    (current-types types)))

;; (A) The basic idea is that a DC module is going to have 7
;; submodules that each do a different thing. Here are what they are:
;;
;; me - Provides the path to the file for other files. Not super
;; interesting, but useful for making the header files appear in the
;; right spot.
;;
;; types - Provides a single export, types, which is a box that
;; contains a list of each TYPE data-structure defined in the
;; module. The header will be created by iterating through this.
;;
;; types-requires - Provides a single export, types-requires, which is
;; a box that contains a list of the modules that this module got
;; exports from. The header file will #include these for their
;; definitions, which may be embedded. We don't need to do this
;; recursively, because we can't refer to their imports unless we
;; require them ourselves. That's Racket's doing.
;;
;; make-header - A module with no exports that when run will produce
;; the header file in the right spot. This could be another
;; program. There's nothing special about it being a submodule.
;;
;; The exact same structure is followed with the other three: exports,
;; exports-requires, and make-blob. There are some differences in the
;; details.
;;
;; exports-requires - Doesn't just share the names of the modules, but
;; also their exports. This is because...
;;
;; make-blob - Can't just use #include, instead it has to search the
;; other blob for where the point to the used exports are. Thus it
;; needs the list. It also needs a list of what it made for internal
;; points. In the real DC, these wouldn't be offsets but actual
;; pointers.
;;
;; 3 of the modules are written by hand and the other four are all
;; generated by a macro. Go to (B)
(define-syntax (begin-submodules stx)
  (syntax-parse stx
    [(_)
     (quasisyntax/loc stx
       (begin
         (module+ me
           (define me
             (build-path #,(syntax-source-directory stx)
                         #,(syntax-source-file-name stx)))
           (provide me))

         (define-cons-param-submod current-types types)
         (define-cons-param-submod current-types-requires types-requires)
         (module+ make-header
           (require (submod ".." types)
                    (submod ".." types-requires)
                    (submod ".." me))
           (make-header (unbox types-requires)
                        (unbox types)
                        me))

         (define-cons-param-submod current-exports exports)
         (define-cons-param-submod current-exports-requires exports-requires)
         (module+ make-blob
           (require (submod ".." exports)
                    (submod ".." exports-requires)
                    (submod ".." me))
           (make-blob (unbox exports-requires)
                      (unbox exports)
                      me))))]))

;; (D) Every one of the DC macros (require, define-*) is going to (1)
;; set up the Racket name and then (2) record whatever information is
;; appropriate in the various DC meta submodules.
;;
(define-syntax-rule (require-for-dc m ...)
  (begin (require-for-dc* m) ...))
;; For instance, a require-for-dc has to...
(define-syntax (require-for-dc* stx)
  (syntax-parse stx
    [(_ m:expr)
     (syntax/loc stx
       (begin
         ;; First, get the actual Racket imports
         (require m)
         ;; Second, record that the types are available, so we should
         ;; do a #include
         (module+ types-requires
           (require (rename-in (submod m me) [me it]))
           (cons-types-requires! (mod->header it)))
         ;; Third, record that the exports are available, so we may
         ;; need to search for pointers.
         (module+ exports-requires
           (require (rename-in (submod m me) [me it])
                    (rename-in (submod m exports) [exports r-es-b]))
           (cons-exports-requires! (cons (mod->blob it) (unbox r-es-b))))))]))
;; Goto next (D)

(define (mod->header in)
  (path-replace-suffix in #".h"))

;; (E) The actual make-header/make-blob functions are not super
;; interesting from a macro perspective, but their simplicity is part
;; of the goodness of this design. Next (E)
(define (make-header REQUIRES TYPES in)
  (define out (mod->header in))
  (with-output-to-file out
    #:exists 'replace
    (λ ()
      (printf "// Header for ~a\n" in)
      (for ([m (in-list REQUIRES)])
        (printf "#include ~v\n" (path->string m)))
      (printf "\n")
      (for ([n*t (in-list TYPES)])
        (match-define (TYPE n t) n*t)
        (printf "typedef ~v ~a;\n" (type-format t) n))
      (printf "\n"))))

(define (mod->blob in)
  (path-replace-suffix in #".blob"))

;; (E) This is intimately connected with value-format that searches
;; through REQs/EXPs for the offset of the thing. Again, not super
;; interesting. Goto (F)
(define (make-blob REQUIRES EXPORTS in)
  (define out (mod->blob in))
  (with-output-to-file out
    #:exists 'replace
    (λ ()
      (printf ";; Blob for ~a\n" in)
      (for ([n*v (in-list EXPORTS)]
            [i (in-naturals)])
        (match-define (EXPORT n t v) n*v)
        (printf ";; ~a. ~a(~a)\n~v\n"
                i n (type-format t)
                (value-format REQUIRES EXPORTS v)))
      (printf "\n"))))

(define (value-format REQUIRES EXPORTS v)
  (let value-format ([v v])
    (match v
      [(EXPORT n _ _)
       (vector '#%ptr
               ;; xxx this O(n) searches could be O(1)
               (or (for/or ([e (in-list EXPORTS)]
                            [i (in-naturals)])
                     (and (eq? e v) i))
                   (for/or ([r (in-list REQUIRES)])
                     (match-define (cons n r-es) r)
                     (for/or ([e (in-list r-es)]
                              [i (in-naturals)])
                       (and (eq? e v) (cons (path->string n) i))))
                   (error 'value-format "Unknown export: ~v" v)))]
      [(cons a d)
       (cons (value-format a) (value-format d))]
      [x
       x])))

(struct TYPE (n v) #:transparent)

(define-syntax-rule (type-ref t)
  ;; XXX replace 'pos and 'neg with better srcloc
  (contract TYPE? t 'pos 'neg))

(define (type-format s)
  (match s
    [(TYPE n _)
     n]
    [(? string?)
     s]
    [(cons a d)
     (cons (type-format a)
           (type-format d))]))

;; (D) define-type does the same thing, but records the presence of a
;; type. Goto next (D)
(define-syntax (define-type stx)
  (syntax-parse stx
    [(_ n:id t:expr)
     (syntax/loc stx
       (begin (define n (TYPE 'n (type-rep t)))
              (provide n)
              (module+ types
                (cons-type! n))))]))

(define-syntax (type-rep stx)
  (syntax-parse stx
    [(_ t:str)
     (syntax/loc stx t)]
    [(_ t:id)
     (syntax/loc stx (type-ref t))]
    [(_ ((~literal cons) t1:expr t2:expr))
     (syntax/loc stx (cons (type-rep t1) (type-rep t2)))]))

(struct problem (type value))
(define (instance-verify t v)
  (match t
    ["long"
     (if (flonum? v)
         empty
         (list (problem t v)))]
    [(TYPE _ t-ref)
     (match v
       [(EXPORT _ vt _)
        (if (eq? vt t)
            empty
            (list (problem t v)))]
       [_
        (define inner (instance-verify t-ref v))
        (if (empty? inner)
            empty
            (cons (problem t v)
                  inner))])]
    [(cons t1 t2)
     (match v
       [(cons v1 v2)
        (append (instance-verify t1 v1)
                (instance-verify t2 v2))]
       [_
        (list (problem t v))])]))

(define (display-problems n ps)
  (printf "~a disobeys its type's specification:\n" n)
  (for ([p (in-list ps)])
    (match-define (problem t v) p)
    (printf "\t~e is not a ~a\n" v (type-format t)))
  (printf "\n"))

;; (D) define-export does the same thing but records an export. Goto
;; (E)
(struct EXPORT (n t v) #:transparent)
(define-syntax (define-export stx)
  (syntax-parse stx
    [(_ n:id t:id v:expr)
     (syntax/loc stx
       (begin
         (define n
           (let* ([vi v]
                  [problems (instance-verify (type-ref t) vi)])
             (cond
              [(empty? problems)
               (EXPORT 'n (type-ref t) vi)]
              [else
               (display-problems 'n problems)
               (error 'define-export)])))
         (provide n)
         (module+ exports
           (cons-export! n))))]))

;; (F) Scripts, types, and exports are all actual Racket values. Here
;; I tag scripts as being special values, but they are really just
;; functions. I think this represents a misunderstanding on my part
;; what makes something a script. Nevertheless, the beauty of all this
;; is that DC code IS Racket code, but it is defined in a such a way
;; that the structure of the module is expose to the
;; make-(header|blob) functions so they can walk through the data and
;; do something to it.
(struct SCRIPT (n v)
        #:transparent
        #:property prop:procedure
        (λ (s . stx)
          (apply (SCRIPT-v s) stx)))
(define-syntax (define-script stx)
  (syntax-parse stx
    [(_ n:id v:expr)
     (syntax/loc stx
       (begin (define n (SCRIPT 'n v))
              (provide n)))]))

;; xxx tighten
(provide (all-defined-out))
